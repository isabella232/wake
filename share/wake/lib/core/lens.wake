# Copyright 2021 SiFive, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You should have received a copy of LICENSE.Apache2 along with
# this software. If not, you may obtain a copy at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
package wake

export def (l: List a) |> (t: a => List b): List b = mapFlat t l

# TODO: How do we feel about `x | f |> g` vs `|> x |> f |> g`?
export def |> (x: a): List a = x, Nil

# NOTE: These are not part of an offline discussion but I think they're a
#       useful concept. They're a kind of horizontial composition rather
#       than vertical. You can use them to do things like set/get a value
#       in a fallback like way. We can drop these. getJString made me
#       think we might want something like this for some unknown reason
#
# Example:
#     def getJString j =
#         |> j
#         |> jString ++> (_ | jArray |> jString)
#
#     # The edit version is a lot more tricky to use
#     def editJString f =
#         jeString ++< (jeArray $ jeString $ _) $ f
export def (t1: a => List b) ++> (t2: a => List b): a => List b =
    def view s = (t1 s) ++ (t2 s)
    view

export def (e1: (a => b) => s => s) ++< (e2: (a => b) => s => s): (a => b) => s => s =
    def edit f s = e1 f s | e2 f
    edit

# Ported from the jq tutorial
export def example1 (j: JValue): Result JValue Error = Pass j
export def example2 (j: JValue): Result JValue Error =
    j | jAt 0 | expectOne "j was empty"

# Simplify github json first commit
export def example3 (log: JValue): Result JValue Error =
    require Pass commit =
        log
        | jAt 0
        | expectOne "expected at least one commit"

    require Pass message =
        commit
        | jField "commit" |> jField "message"
        | expectOne ".commit.message missing"

    require Pass name =
        commit
        | jField "commit" |> jField "name"
        | expectOne ".commit.name missing"

    JObject ("message" :-> message, "name" :-> name, Nil) | Pass

# Simplify github json log
export def example4 (log: JValue): Result JValue Error =
    def simpleCommit commit =
        require Pass message =
            commit
            | jField "commit" |> jField "message"
            | expectOne ".commit.message missing"

        require Pass name =
            commit
            | jField "commit" |> jField "name"
            | expectOne ".commit.name missing"

        JObject ("message" :-> message, "name" :-> name, Nil) | Pass

    # This is a bit complicated IMO but not too bad
    log
    | jAll
    | findFailFn simpleCommit
    | rmap JArray

# Simplify github json log
export def example5 (log: JValue): Result JValue Error =
    def simpleCommit commit =
        require Pass message =
            commit
            | jField "commit" |> jField "message"
            | expectOne ".commit.message missing"

        require Pass name =
            commit
            | jField "commit" |> jField "name"
            | expectOne ".commit.name missing"

        def parents = commit | jField "parents" |> jAll |> jField "html_url" | JArray

        JObject ("message" :-> message, "name" :-> name, "parents" :-> parents, Nil)
        | Pass

    # This is a bit complicated IMO but not too bad
    log
    | jAll
    | findFailFn simpleCommit
    | rmap JArray

# Convert a git log to a simplified wake tuple
export tuple Commit =
  Message: String
  Name: String
  Parents: List String

# Simplify github json log
export def example6 (log: JValue): Result (List Commit) Error =
    def simpleCommit commit =
        require Pass message =
            commit
            | jField "commit" |> jField "message"
            |> jString
            | expectOne ".commit.message was missing or not a string"

        require Pass name =
            commit
            | jField "commit" |> jField "name"
            |> jString
            | expectOne ".commit.name missing or not a string"

        def parents = commit | jField "parents" |> jAll |> jField "html_url" |> jString

        Commit message name parents
        | Pass

    # This is a bit complicated IMO but not too bad
    log
    | jAll
    | findFailFn simpleCommit

# It turns out, edit functions compose with `$` in the order you want
# which is somehow surprising and obvious at the same time. Who knew?
export def exampleEdit1: Pair Integer b => Pair Integer b =
    editPairFirst $ (_+4)

export def exampleEdit2: Triple (Pair a Integer) b c => Triple (Pair a Integer) b c =
    editTripleFirst $ editPairSecond $ (_+4)

export def exampleEdit3: JValue => JValue =
    jeField "hello"
    $ jeField "bar"
    $ jeString
    $ ("zzz{_}zzz")