# Copyright 2019 SiFive, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You should have received a copy of LICENSE.Apache2 along with
# this software. If not, you may obtain a copy at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

package wake

# The JSON data type
export data JValue =
  JString  String
  JInteger Integer
  JDouble  Double
  JBoolean Boolean
  JNull
  JObject  (List (Pair String JValue))
  JArray   (List JValue)

export def getJString: JValue => Option String = match _
  JString x               = Some x
  JArray (JString x, Nil) = Some x
  _                       = None
export def getJInteger: JValue => Option Integer = match _
  JInteger x               = Some x
  JArray (JInteger x, Nil) = Some x
  _                        = None
export def getJDouble: JValue => Option Double = match _
  JDouble x               = Some x
  JInteger x              = dint x | Some
  JArray (JDouble x, Nil) = Some x
  JArray (JInteger x, Nil)= dint x | Some
  _                       = None
export def getJBoolean: JValue => Option Boolean = match _
  JBoolean x               = Some x
  JArray (JBoolean x, Nil) = Some x
  _                        = None
export def getJObject: JValue => Option (List (Pair String JValue)) = match _
  JObject x               = Some x
  JArray (JObject x, Nil) = Some x
  _                       = None
export def getJArray: JValue => Option (List JValue) = match _
  JArray x = Some x
  _        = None

export def parseJSONBody (body: String): Result JValue Error =
  def imp b = prim "json_body"
  match (imp body)
    Pass jvalue = Pass jvalue
    Fail cause = Fail (makeError cause)

export def parseJSONFile (path: Path): Result JValue Error =
    def imp f =
        prim "json_file"
    match (imp path.getPathName)
        Pass body = Pass body
        Fail f = Fail (makeError f)

export def jsonEscape str = prim "json_str"

tuple JSONFormat =
  export String:  String  => String
  export Integer: Integer => String
  export Double:  Double  => String
  export Indent:  Integer

def doFormat (fmt: JSONFormat) (lhs: JValue): List String =
  def indent = fmt.getJSONFormatIndent
  def space = if indent > 0 then " " else ""
  def indention = tab (\_ ' ') indent | cat
  def rec rhs depth lhs =
    def deeper = omap ("{indention}{_}") depth
    def tabbed = omap ("\n{_}") depth | getOrElse ""
    def tabbeder = omap ("\n{_}") deeper | getOrElse ""
    match lhs
      JString  s    = '"', fmt.getJSONFormatString s, '"', rhs
      JInteger i    = fmt.getJSONFormatInteger i,          rhs
      JDouble  d    = fmt.getJSONFormatDouble d,           rhs
      JBoolean True = "true",   rhs
      JBoolean False= "false",  rhs
      JNull         = "null",   rhs
      JArray   list =
        def helper value acc = ",{tabbeder}", rec acc deeper value
        if list.empty then '[]', rhs
        else "[{tabbeder}", foldr helper ("{tabbed}]", rhs) list | tail
      JObject  list =
        def helper (Pair key value) acc =
          ",{tabbeder}", '"', jsonEscape key, ("\":{space}", rec acc deeper value)
        if list.empty then '{}', rhs
        else "\{{tabbeder}", foldr helper ("{tabbed}\}", rhs) list | tail
  rec Nil (if indent > 0 then Some "" else None) lhs

export def defaultJSONFormat: JSONFormat =
  def formatDouble d =
    match (dclass d)
      DoubleInfinite if d <. 0e0 = "-Infinity"
      DoubleInfinite = "Infinity"
      DoubleNaN      = "NaN"
      _              = dstr d
  JSONFormat jsonEscape str formatDouble 0

export def prettyJSONFormat = defaultJSONFormat | setJSONFormatIndent 2

export def customFormatJSON fmt body = doFormat fmt body | cat
export def formatJSON = customFormatJSON defaultJSONFormat
export def prettyJSON = customFormatJSON prettyJSONFormat

export def root /| filterFn = jfilter filterFn root
export def jfilter filterFn root = match root
  JArray l = JArray (filter filterFn l)
  _ = if filterFn root then JArray (root, Nil) else JArray Nil

export def root /../ filterFn = jfind filterFn root
export def jfind filterFn root =
  def helper node acc = match node
    JArray l =
      def tail = foldr helper acc l
      if filterFn node then node, tail else tail
    JObject l =
      def tail = foldr (helper _.getPairSecond _) acc l
      if filterFn node then node, tail else tail
    _ =
      if filterFn node then node, acc else acc
  helper root Nil | JArray

export def jempty root = empty (jlist root)
export def jlist root = match root
  JArray x = x
  _ = root, Nil

export def x // y =
  def helper tail = match _
    JString  _ = tail
    JInteger _ = tail
    JDouble  _ = tail
    JBoolean _ = tail
    JNull      = tail
    JObject  l =
      def flatten v tail = match v.getPairSecond
        JArray l = l ++ tail
        w = w, tail
      foldr flatten tail (filter (matches y _.getPairFirst) l)
    JArray   l =
      def flatten v tail = helper tail v
      foldr flatten tail l
  JArray (helper Nil x)

# Compares two json values for equality. Returns
# True if the two json values are identical and
# false otherwise. In JavaScript this would be
# called "deep equality".
#
# Examples:
# ```
#   JInteger 10 ==/ JInteger 10 = True
#   JInteger 11 ==/ JInteger 10 = False
#   JInteger 10 ==/ JString "foo" = False
#   JNull ==/ JNull = True
#   JArray (JString "foo", Nil) ==/ JArray (JString "foo", Nil) = True
#   JArray Nil ==/ JArray Nil = True
#   JObject ("name" :-> JString "Bob", Nil) ==/ JObject ("name" :-> JString "Bob", Nil) = True
#   JObject Nil = JObject Nil
#   JArray JNull ==/ JArray (JInteger 10) = False
# ```
export def x ==/ y = match x y
  (JString  a) (JString  b) = a ==~ b
  (JInteger a) (JInteger b) = a ==  b
  (JDouble  a) (JDouble  b) = a ==. b
  (JInteger a) (JDouble b)  =
    def Pair whole frac = dmodf b
    if frac ==. 0.0 then whole == a else False
  (JDouble a) (JInteger b) = JInteger b ==/ JDouble a
  (JBoolean a) (JBoolean b) = if a then b else !b
  JNull        JNull        = True
  (JObject  a) (JObject  b) =
    def helper (Pair (Pair k c) (Pair l d)) = k ==~ l && c ==/ d
    if a.len != b.len then False else zip a b | forall helper
  (JArray   a) (JArray   b) =
    def helper (Pair c d) = c ==/ d
    if a.len != b.len then False else zip a b | forall helper
  _ _ = False

# Simplify a JSON structure for broad compatibility as defined by the specs.
# While doing so is unnecessary where Wake is always used to consume any
# generated file, in environments where output may be passed to a different tool
# (especially when that tool is not known at the time of generation, e.g., in a
# web service) this can be helpful to prevent failures and/or undefined behavior
# in the downstream clients.
#
# This is equivalent to calling `normalizeJSONWith` using the rules defined by
# `normalizeJSONCompat`.
export def normalizeJSON: (json: JValue) => Result JValue Error =
    normalizeJSONWith normalizeJSONCompat

# Simplify a JSON structure according to the rules given.
# For example, Wake's implementation of JSON is more lenient than the base
# standards, so if maximum compatibility is desired in situations where some
# other implementation may be parsing generated output, `normalizeJSONCompat`
# may be used to target that lowest common denominator (see `normalizeJSON` for
# that particular case).
#
# Note that the relevant normalization is applied to each member of a `JArray`
# or `JObject` *before* the enclosing container. This means that if some
# normalization fails anywhere in the JSON tree the entire call will fail, even
# if the specific branch causing the failure would later have been pruned.
export def normalizeJSONWith (fmt: JSONNormalize) (json: JValue): Result JValue Error =
    def normalized = match json
        JString a =
            getJSONNormalizeString fmt a
            | rmap JString
        JInteger a =
            getJSONNormalizeInteger fmt a
            | rmap JInteger
        JDouble a =
            getJSONNormalizeDouble fmt a
            | rmap JDouble
        JBoolean a =
            getJSONNormalizeBoolean fmt a
            | rmap JBoolean
        JNull =
            Pass JNull
        JObject a =
            def normalizeJObjectValue entry =
                def Pair key value =
                    entry
                def normalized =
                    normalizeJSONWith fmt value
                match normalized
                    (Pass norm)  = Pass (Pair key norm)
                    (Fail error) = addJSONErrorPath key error
            def normalizedList =
                map normalizeJObjectValue a
            require Pass children =
                findFail normalizedList
            children
            | getJSONNormalizeObject fmt
            | rmap JObject
        JArray a =
            def recurseArray (Pair i x) =
                normalizeJSONWith fmt x
                | rmapFail (addJSONErrorPath "[{str i}]")
            require Pass normalized =
                zip (seq a.len) a
                | findFailFn recurseArray
            normalized
            | getJSONNormalizeArray fmt
            | rmap JArray
    normalized
    | rmapFail (addJSONErrorPath "")

# Attempt to merge several JSON structures, while resolving any duplicate keys.
# In particular, this function will concatenate the members of two `JArray`
# values, treat `JNull` as a wildcard placeholder, and otherwise return the
# original value if both instances are equal. It fails if the same location in
# the object tree is associated with multiple values of different types or with
# different values of a type which cannot be combined. Returns a `JNull` value
# if passed an empty list.
export def mergeJSON (jsons: List JValue): Result JValue Error =
    def removeDummyFromError error =
        def removeKeyFromError cause =
            if matches `/key:.*` cause then
                replace `^/key:` "/:" cause
            else if matches `/key.*` cause then
                replace `^/key` "" cause
            else
                cause
        error
        | editErrorCause removeKeyFromError
        | Fail
    require Pass joinedList =
        # Create a dummy key to take advantage of object key deduplication infrastructure.
        map (Pair "key") jsons
        | deduplicateJObjectKeys (mergeValueList False)
        | rmapFail removeDummyFromError
    require joinedValue, _ =
        joinedList
        | map getPairSecond
    else
        Pass JNull
    Pass joinedValue

# Use the value of the key appearing last in the list, but recurse into `JObject`s.
# Essentially, allows overwriting any key in the object tree by specifying a new
# value at the same place in a later tree. Returns `JNull` if given an empty list.
#
# If some location has *both* `JObject` values and values of other types, any
# `JObject` values before the last non-`JObject` value will be dropped:
#
# ```
# ("\{\"key\":\{\"firstSubkey\":1\}\}", "\{\"key\":\{\"secondSubkey\":2\}\}", Nil)
# | findFailFn parseJSONBody
# | rmapPass lastValueInList
# | rmap formatJSON
# Pass "\{\"key\":\{\"firstSubkey\":1,\"secondSubkey\":2\}\}"
# ```
#
# ```
# ("\{\"firstKey\":1\}", "2", "\{\"secondKey\":3\}", Nil)
# | findFailFn parseJSONBody
# | rmapPass lastValueInList
# | rmap formatJSON
# Pass "\{\"secondKey\":3\}"
# ```
export def overrideJSON (jsons: List JValue): JValue =
    def joinedList =
        map (Pair "key") jsons
        | deduplicateJObjectKeys lastValueInList
        | getPass
        | getOrElseFn (\_ unreachable "lastValueInList invariant reached in overrideJSON")
    require joinedValue, _ =
        joinedList
        | map getPairSecond
    else
        JNull
    joinedValue

# Prepend the given path segment to an error message, to be called by `rmapFail`.
# This is meant to be called bottom-up, with the inner-most object/array passing
# the key/index followed by its parent, etc.
#
# Parameters:
#  - `node`: The path segment to prepend, without any leading or trailing
#     separator. The root node should pass the empty string `""`.
#  - `error`: The report which should be annotated with path info.
def addJSONErrorPath (node: String) (error: Error): Result a Error =
    def prependNode cause =
        if matches `/:.*` cause then
            replace `^/` "/{node}" cause
        else if matches `/.*` cause then
            if strlen node == 0 then
                cause
            else
            "/{node}{cause}"
        else
            "/{node}: {cause}"
    error
    | editErrorCause prependNode
    | Fail

# The rules by which `normalizeJSONWith` will simplify JSON values.
# If any particular function is unable to operate on every input value (e.g. a
# `JObject` contains duplicate keys of types which cannot be combined), that
# rule may return a `Fail` which halts the broader processing.
export tuple JSONNormalize =
    String: String => Result String Error
    Integer: Integer => Result Integer Error
    Double: Double => Result Double Error
    Boolean: Boolean => Result Boolean Error
    Object: List (Pair String JValue) => Result (List (Pair String JValue)) Error
    Array: List JValue => Result (List JValue) Error

# A basic normalization ruleset which returns inputs unchanged.
export def normalizeJSONIdentity: JSONNormalize =
    JSONNormalize Pass Pass Pass Pass Pass Pass

# Target the minimum JSON language described by the specifications.
export def normalizeJSONCompat: JSONNormalize =
    def nfkcKeys =
        map (editPairFirst unicodeIdentifier)
    normalizeJSONIdentity
    | setJSONNormalizeString (Pass _.unicodeCanonical)
    | setJSONNormalizeDouble filterNonDigitJDouble
    | setJSONNormalizeObject (deduplicateJObjectKeys (mergeValueList True) _.nfkcKeys)

# Fail on any `Double` values which can't be represented numerically.
# Published JSON specifications describe their double values as allowing decimal
# or exponential forms, but don't implement the full IEEE standard.
def filterNonDigitJDouble (n: Double): Result Double Error = match n.dclass
    DoubleInfinite =
        failWithError "For compatibility, JSON doubles should not be infinite."
    DoubleNaN =
        failWithError "For compatibility, JSON doubles should not be NaN values."
    _ =
        Pass n

# Attempt to simplify any `JObject`s which contain multiple instances of a key.
# While the published specifications explicitly allow such duplicate keys, none
# *require* implementations to accept them nor describes the behaviour by which
# they should be handled; therefore, implementations differ in how they handle
# duplicate keys -- if they do so at all -- and a generator aiming for
# compatibility shouldn't output objects with duplicate keys.
#
# In particular, this function will concatenate the members of two `JArray`
# values, treat `JNull` as a wildcard placeholder, and otherwise return the
# original value if both instances are equal. It fails if a key is associated
# with multiple values of different types or with different values of a type
# which cannot be combined.
#
# Parameters:
#  - `simplifyValueList`: The function used to reduce multiple occurances of an
#    object key to a single value. This may safely assume that it is never
#    passed an empty list.
#  - `dict`: The original key-value pairs from which any duplicate keys should
#    be removed.
def deduplicateJObjectKeys (simplifyValueList: List JValue => Result JValue Error) (dict: List (Pair String JValue)): Result (List (Pair String JValue)) Error =
    def cmpKeysOnly (Pair k1 _) (Pair k2 _) =
        k1 <* k2
    def simplifyKeyGroup (pairs: List (Pair String JValue)): Result (Pair String JValue) Error =
        match pairs
            Nil =
                # `simplifyKeyGroups` is only ever mapped over the output of
                # `groupBy`, which is always a list of *non-empty* lists.
                unreachable "groupBy invariant reached in deduplicateJObjectKeys"
            (Pair key value), ps =
                def simplified =
                    (value, map getPairSecond ps: List JValue)
                    | simplifyValues
                match simplified
                    (Pass value) = Pass (Pair key value)
                    (Fail error) = addJSONErrorPath key error
    def simplifyValues (values: List JValue): Result JValue Error =
        match values
            v, Nil = Pass v
            _      = simplifyValueList values
    groupBy cmpKeysOnly dict
    | findFailFn simplifyKeyGroup

# Attempt to determine equality across simple values, concatenate `JArray`s, and
# recurse into `JObject`s.
def mergeValueList (describeCompat: Boolean) (values: List JValue): Result JValue Error =
    # This function is used both in normalization (which benefits from showing
    # the user why something was rejected) and merging (where the user should
    # already know it might fail); this conditionally prints a descriptive
    # message depending on that environment.
    def compatibilityMessage upper lower error =
        if describeCompat then
            ("For compatibility, JSON objects should not have duplicate keys. While we try to recover from this where possible, ", lower, error, Nil)
            | cat
        else
            (upper, error, Nil)
            | cat
    def requireEqual eqFn wrapFn values =
        def eqOrFail x y =
            if eqFn x y then
                Pass x
            else
                compatibilityMessage "N" "n" "ot every type can combine multiple different values. The incompatible values are: {map wrapFn values | formatExamples}"
                | failWithError
        match values
            v1, v2, vs =
                rfoldl eqOrFail v1 (v2, vs)
                | rmap wrapFn
            v, Nil =
                Pass (wrapFn v)
            _ =
                unreachable "groupBy invariant reached in mergeValueList"
    def formatExamples examples =
        map formatJSON examples
        | catWith ", "
        | ("[{_}]")
    def (nullTest; stringTest; intTest; doubleTest; boolTest; objectTest; arrayTest) =
        # We filter out `JNull` values for most types as being a "wildcard"
        # value, but if *everything* is a `JNull` we do want to return that.
        def isNull = match _
            JNull = True
            _     = False
        def allNull =
            forall isNull values
        def nonNullValues =
            filter (! _.isNull) values
        # The `getJ*` functions also return `Some` for single-element arrays
        # of the proper type, but we don't want that fallback when merging.
        def anyArray =
            exists (_.getJArray | isSome) values
        match allNull anyArray
            True _ =
                Some values; None; None; None; None; None; None
            _ True =
                def arrays =
                    def getJArrayOrNull = match _
                        JNull = Some (JNull, Nil)
                        json  = getJArray json
                    findNoneFn getJArrayOrNull values
                None; None; None; None; None; None; arrays
            _ _ =
                # If *all* values are of the same type, get those values.
                def strings =
                    findNoneFn getJString nonNullValues
                def ints =
                    findNoneFn getJInteger nonNullValues
                def doubles =
                    # `getJDouble` will convert any `JInteger` values.
                    def isDouble = match _
                        JDouble _ = True
                        _ = False
                    if forall isDouble nonNullValues then
                        findNoneFn getJDouble nonNullValues
                    else
                        None
                def bools =
                    findNoneFn getJBoolean nonNullValues
                def objects =
                    findNoneFn getJObject nonNullValues
                None; strings; ints; doubles; bools; objects; None
    match nullTest stringTest intTest doubleTest boolTest objectTest arrayTest
        (Some _) None None None None None None =
            Pass JNull
        _ (Some strings) None None None None None =
            requireEqual (_==*_) JString strings
        _ None (Some ints) None None None None =
            requireEqual (_==_) JInteger ints
        _ None None (Some doubles) None None None =
            requireEqual (_==._) JDouble doubles
        _ None None None (Some bools) None None =
            requireEqual enor JBoolean bools
        _ None None None None (Some objects) None =
            # If multiple keys all point to a `JObject`, there's a chance
            # keys are shared between those objects (even if not within the
            # objects individually) and so they need to be deduplicated
            # further.  This unfortunately bumps the total normalization
            # complexity to O(n^2), but that worst-case complexity should
            # very rarely be hit (note that any key with a single occurance
            # is returned unchanged by `simplifyValues`).
            flatten objects
            | deduplicateJObjectKeys (mergeValueList describeCompat)
            | rmap JObject
        _ None None None None None (Some arrays) =
            flatten arrays
            | JArray
            | Pass
        _ _ _ _ _ _ _ =
            compatibilityMessage "V" "v" "alues of different types may not be combined. The incompatible values are: {formatExamples values}"
            | failWithError

# Use the value of the key appearing last in the list, but recurse into `JObject`s.
# Essentially, allows overwriting any key in the object tree by specifying a new
# value at the same place in a later tree. Will always always succeed, returning
# `Pass JNull` if given an empty list.
#
# See `overrideJSON` for examples of usage.
export def lastValueInList (values: List JValue): Result JValue Error =
    def revValues =
        reverse values
    def isNotObject = match _
        JObject _ = False
        _         = True
    match (takeUntil isNotObject revValues)
        Nil =
            revValues
            | head
            | getOrElse JNull
            | Pass
        objs =
            # Return to original order after taking from `revValues`.
            reverse objs
            | mapPartial getJObject
            | flatten
            | deduplicateJObjectKeys lastValueInList
            | rmap JObject

# TODO: Update documentation
# If the input is a string, returns a singelton list
# containing that string. This can be used to extract
# a string from a JValue or in list operation chains
# as a safe JValue to String conversion.
#
# Examples:
# ```
#   jString (JString "foo") = "foo", Nil
#   jString (JInteger 10) = Nil
#   single json |> jField "name" |> jString = "Alice", Nil
#   single json |> jField "age" |> jString = Nil
# ```
export def jString (getFn: String => Result a Error): JValue => Result a Error = match _
    JString s = getFn s
    _         = failWithError "not a string"

# TODO: Fix this doc
# If `input` is a JString, updates the string using `editFn`.
#
# Parameters:
#   - `editFn`: The function to update a string with
#   - `input`: the JValue to be modified
#
# Examples:
# ```
#   editJString ("{_}man") (JString "bat") = JString "batman"
#   editJString ("{_}man") (JInteger 10) = JInteger 10
#   (editJField "name" $ editJString ("I'm {_}")) batman = JObject ("name" :-> JString "I'm batman", Nil)
#   def rename (newName: String): (person: JValue) => JValue = editJField "name" $ editJString (\_ newName)
# ```
export def editJString (editFn: String => Result String Error): (input: JValue) => Result JValue Error = match _
    JString s =
        require Pass es = editFn s
        Pass (JString es)
    _         = failWithError "not a string"

# TODO: Update documentation
# If the input is an integer, returns a singelton list
# containing that integer. This can be used to extract
# an integer from a JValue or in list operation chains
# as a safe JValue to Integer conversion. This works
# even if the underlying value is represented as a
# Double as long as the double has no fractional part.
#
# Examples:
# ```
#   jInteger (JInteger 10) = 10, Nil
#   jInteger (JDouble 10.0) = 10, Nil
#   jInteger (JString "foo") = Nil
#   jInteger (JDouble 3.14) = Nil
#   single json |> jField "age" |> jInteger = 28, Nil
#   single json |> jField "name" |> jInteger = Nil
# ```
export def jInteger (getFn: Integer => Result a Error): JValue => Result a Error = match _
    JInteger i = getFn i
    JDouble d =
        def Pair whole frac = dmodf d
        if frac ==. 0.0 then getFn whole else failWithError "not an integer"
    _          = failWithError "not an integer"

# TODO: Fix this doc
# If `input` is a JInteger, editJInteger updates the integer
# using `editFn`. If `input` is a JDouble and the double has
# no fractional part, the double is first converted to an
# integer and then updated as an integer. The result is
# a JInteger in both cases.
#
# Parameters:
#   - `editFn`: The function to update an integer with
#   - `input`: The JValue to be modified
#
# Examples:
# ```
#   editJInteger (_+1) (JInteger 10) = JInteger 11
#   editJInteger (_+1) (JDouble 10.0) = JInteger 11
#   editJInteger (_+1) (JString "Bob") = JString "Bob"
#   editJInteger (_+1) (JDouble 3.14) = JDouble 3.14
#   (editJField "daysSinceAccident" $ editJInteger (\_ 0)) statistics
#   def birthday: (person: JValue) => JValue = editJField "age" $ editJInteger (_+1)
# ```
export def editJInteger (f: Integer => Result Integer Error): JValue => Result JValue Error = match _
    JInteger i =
        require Pass ei = f i
        Pass (JInteger ei)
    JDouble d =
        def Pair whole frac = dmodf d
        if frac ==. 0.0 then
            require Pass ei = f whole
            Pass (JInteger ei)
        else
            failWithError "not an integer"
    _          = failWithError "not an integer"

# TODO: Update this documentation
# If the input is a boolean, returns a singelton list
# containing that boolean. This can be used to extract
# a boolean from a JValue or in list operation chains
# as a safe JValue to Boolean conversion.
#
# Examples:
# ```
#   jBoolean (JBoolean False) = False, Nil
#   jBoolean (JString "foo") = Nil
#   single json |> jField "frysWithThat" |> jBoolean = True, Nil
#   single json |> jField "name" |> jBoolean = Nil
# ```
export def jBoolean (getFn: Boolean => Result a Error): JValue => Result a Error = match _
    JBoolean b = getFn b
    _          = failWithError "not a boolean"

# TODO: Update documentation
# If `input` is a JBoolean, updates the boolean using `editFn`.
#
# Parameters:
#   - `editFn`: The function to update a boolean with
#   - `input`: The JValue to be modified
#
# Examples:
# ```
#   editJBoolean (_&&False) (JBoolean True) = JBoolean False
#   editJBoolean (_||True) (JInteger 10) = JInteger 10
#   def addFries: (order: JValue) => JValue = (editJField "friesWithThat" $ editJBoolean (\_ True)) order
#   def ketchupOnSide: (order: JValue) => JValue = editJField "ketchupOnSide" $ editJBoolean (\_ True)
# ```
export def editJBoolean (f: Boolean => Result Boolean Error): JValue => Result JValue Error = match _
    JBoolean b =
        require Pass eb = f b
        Pass (JBoolean eb)
    _          = failWithError "not a boolean"

# TODO: Update documentation
# If the input is a number, returns a singelton list
# containing that number as a double. This can be used
# to extract a number from a JValue or in list operation
# chains as a safe JValue to number conversion.
#
# This works with both JDouble and JInteger. An integer
# will be converted to a double, becoming -inf or inf if
# no smaller double exists to aproximate the integer.
#
#
# Examples:
# ```
#   jDouble (JDouble 3.14) = 3.14, Nil
#   jDouble (JInteger 10) = 10.0, Nil
#   jDouble (JInteger (1 << 2000)) = inf, Nil
#   single json |> jField "height" |> jDouble = 1.75, Nil
#   single json |> jField "name" |> jDouble = Nil
# ```
export def jDouble (getFn: Double => Result a Error): JValue => Result a Error = match _
    JDouble d  = getFn d
    JInteger i = getFn (dint i)
    _          = failWithError "not a number"

# TODO: Update documentation
# If `input` is a JDouble, updates the double using `editFn`.
# If `input` is a JInteger then it converts the integer to a
# double before applying `editFn`. The resulting JValue will
# be a JDouble in either case. Integers outside of the range
# of a Double will be converted to negative infinity or
# infinity depending on their sign prior to being passed to
# `editFn`.
#
# Parameters:
#   - `editFn`: The function to update a double with
#   - `input`: The JValue to be modified
#
# Examples:
# ```
#   editJDouble (_+.3.14) (JDouble 2.71) = JDouble 5.85
#   editJDouble (_+.1.0) (JInteger 10) = JDouble 11.0
#   editJDouble (_+.1.0) (JString "Bob") = JString "Bob"
#   editJDouble (_+.1.0) (JInteger (1 << 2000)) = JDouble inf
#   editJDouble (_+.1.0)
#   (editJField "tallestBuilding" $ editJDouble (\_ 1000.0)) statistics
#   def grow: (person: JValue) => JValue = editJField "height" $ editJDouble (_+.0.02)
# ```
export def editJDouble (f: Double => Result Double Error): JValue => Result JValue Error = match _
    JDouble d =
        require Pass ed = f d
        Pass (JDouble ed)
    JInteger i =
        require Pass ed =
            dint i
            | f
        Pass (JDouble ed)
    _ = failWithError "not a number"

# TODO: Fix
# Returns an singelton list containing Unit if
# the input is JNull and an empty list otherwise.
# This should not be used as a way to test for JNull
# but instead when composing with operations on JValue.
# If you need to test if a JValue is Null use `value ==/ JNull`
# instead.
#
# Examples:
# ```
#   single JNull |> jNull = Unit, Nil
#   single (JInteger 0) | jNull = Nil
#   single plans |> jField "emergencyPlan" |> jNull | map (\_ "Break Glass")
#   single sales |> jField "total" |> (\t jInteger t ++ jNull t | map (\_ 0))
# ```
export def jNull (getFn: Unit => Result a Error): JValue => Result a Error = match _
    JNull = getFn Unit
    _     = failWithError "not null"

# TODO: Fix docs
# Performs an effect given by `effect` if the input is
# a JNull.
#
# Examples:
# ```
#   editJNull (\_ print "Hello, World!\n") JNull        # Prints Hello World
#   editJNull (\_ print "Hello, World!\n") (JInteger 0) # Does nothing
# ```
export def editJNull (effect: Unit => Result Unit Error): JValue => Result JValue Error = match _
    JNull =
        require Pass _ = effect Unit # f could have an effect so we can't eliminate it
        Pass JNull
    _     = failWithError "not null"

# TODO: Fix
# Returns a singelton list containing the list of key-value
# pairs from a JObject. If the input is not a JObject, Nil
# is returned instead. Consider using jField or jFieldMatch
# instead of this if possible.
#
# Examples:
# ```
#   single (JObject ("foo" :-> JNull, Nil)) |> jObject | flatten = "foo" :-> JNull, Nil
#   single (JInteger 0) |> jObject | flatten = Nil
# ```
export def jObject (getFn: List (Pair String JValue) => Result a Error): JValue => Result a Error = match _
    JObject obj = getFn obj
    _           = failWithError "not an object"

# TODO: fix docs
# If `input` is a JObject, updates the list of key-value pairs with `editFn`.
# Consider using editJField or editJFieldMatch instead of this if possible.
#
# Examples:
# ```
#   def birthday = editJObject $ editLookup (_==~"age") $ (_+1)
# ```
export def editJObject (editFn: List (Pair String JValue) => Result (List (Pair String JValue)) Error): (input: JValue) => Result JValue Error = match _
    JObject obj =
        require Pass eobj = editFn obj
        Pass (JObject eobj)
    _           = failWithError "not an object"

# TODO: Fix
# If `input` is a JArray, returns a singelton list containing that JArray.
# If `input` is anything else Nil is returned. Consider using jFlatten
# instead of this if possible.
#
# Examples:
# ```
#   single (JArray (JNull, JString "foo", JInteger 10, Nil)) |> jArray | flatten = JNull, JString "foo", JInteger 10
#   single (JArray l) |> jArray = l, Nil
# ```
export def jArray (getFn: List JValue => Result a Error): JValue => Result a Error = match _
    JArray arr = getFn arr
    _          = failWithError "not an array"

# TODO: Add docs
export def editJArray (f: List JValue => Result (List JValue) Error): JValue => Result JValue Error = match _
    JArray arr =
        require Pass earr = f arr
        Pass (JArray earr)
    _          = failWithError "not an array"

# TODO: Fix
# If `input` is a JArray, returns the list it contains. If `input` is
# anything else Nil is returned.
#
# Examples:
# ```
#   single (JArray (JNull, JString "foo", JInteger 10, Nil)) |> jArray | flatten = JNull, JString "foo", JInteger 10
#   single (JArray l) |> jArray = l, Nil
# ```
export def jMap (getFn: JValue => Result a Error): (input: JValue) => Result (List a) Error = match _
  # TOOD: The error should tell you where the failure occured
  JArray arr = map getFn arr | findFail
  _        = failWithError "not an array"

export def jFlatten (getFn: JValue => Result (List a) Error): (input: JValue) => Result (List a) Error =
  # TOOD: The error should tell you where the failure occured
  jArray $ getFlat $ getFn

# TODO: Add docs
export def editJFlatten: (JValue => Result JValue Error) => JValue => Result JValue Error =
   # TODO: The error should tell you where the failure occured
    editJArray $ findFailFn $ _

# TODO: Fix
# If `input` is a JArray with length less than `i`,
# returns a singelton list containting the i-th element.
# Otherwise Nil is returned.
#
# Example:
# ```
#   single (map JInteger (3, 687, 41, 13, 45, Nil) | JArray) |> jAt 2 = JInteger 41, Nil
#   single (JInteger 10) |> jAt 2 = Nil
# ```
export def jAt (i: Integer) (getFn: JValue => Result a Error): (arr: JValue) => Result a Error = match _
    JArray arr =
        require Some elem = at i arr else failWithError "[{str i}]: out of bounds"
        getFn elem
        | addErrorContext "[{str i}]"
    _ = failWithError "not an array"

export def editJAt (i: Integer) (editFn: JValue => Result JValue Error): (input: JValue) => Result JValue Error =
    def helper element =
        addErrorContext "[{str i}]" (editFn element)
    editJArray $ editAt i $ helper

# TODO: fix...also should this return a list?
# If `input` is a JObject returns a list containting
# the values mapped to by `field`. If `input` is not
# a JObject, Nil is returned.
#
# Example:
# ```
#   single person |> jField "name" = JString "Alice", Nil
#   single person |> jField "age" = JInteger 28, Nil
#   single (JInteger 10) |> jAt 2 = Nil
# ```
export def jField (field: String) (getFn: JValue => Result a Error): JValue => Result a Error = match _
    JObject pairs =
        match (lookup (_==~field) pairs)
            Nil    = failWithError "key \"{field}\" not found"
            x, Nil = getFn x
            _      = failWithError "key \"{field}\" found multiple times, expected only once"
    _             = failWithError "not an object"

export def editJField (field: String) (editFn: JValue => Result JValue Error) (input: JValue): Result JValue Error =
    require JObject obj = input else failWithError "not an object"
    def editPairSecondFindFail (Pair x y) =
        require Pass ey = editFn y
        Pass (Pair x ey)
    def Pair count result = editFilterFindFailCount (field ==~ _.getPairFirst) editPairSecondFindFail obj
    if count == 0 then
        failWithError "key {field} not found"
    else
        require Pass eobj = result
        JObject eobj | Pass

# TODO: fix
# If `input` is a JObject with keys equal to `field`,
# returns a list containting the values mapped to by that
# field. If `input` is not a JObject, Nil is returned.
#
# Example:
# ```
#   single person |> jField "name" = JString "Alice", Nil
#   single person |> jField "age" = JInteger 28, Nil
#   single (JInteger 10) |> jAt 2 = Nil
# ```
export def jFieldMatch (field: RegExp) (getFn: JValue => Result (List a) Error): (input: JValue) => Result (List a) Error = match _
    JObject pairs = match (lookup (matches field) pairs)
        Nil    = failWithError "no keys matching `{regExpToString field}` found"
        values = map getFn values | findFail | rmap flatten
    _             = failWithError "not an object"

export def editJFieldMatch (field: RegExp): (JValue => Result JValue Error) => JValue => Result JValue Error =
    editJObject $ editLookupFindFail (matches field _) $ _

export def jDescendants (root: JValue): List JValue =
  def helper node acc = match node
    JArray l =
      foldr helper (node, acc) l
    JObject l =
      foldr (helper _.getPairSecond _) (node, acc) l
    _ =
      node, acc
  helper root Nil

export def editJDescendants (editFn: JValue => Result JValue Error) (root: JValue): Result JValue Error =
  def helper node = match node
    JArray l =
      require Pass l2 = map helper l | findFail
      editFn (JArray l2)
    JObject l =
      def sub (k :-> v) =
        require Pass v2 = helper v
        Pass (k :-> v2)
      require Pass l2 = map sub l | findFail
      editFn (JObject l2)
    _ =
      editFn node
  helper root

# Returns True if `input` has a JValue equal to `v`.
#
# Examples:
# ```
#   jExists (JInteger 42) (JInteger 42, JString "cheese", JNull, Nil) = True
#   jExists (JString "Alice") (JInteger 42, JString "cheese", JNull, Nil) = False
#   jExists v Nil = False
# ```
export def jExists (v: JValue): (input: JValue) => Result Boolean Error = _ ==/ v | Pass

# Returns True if `input` is a list containing all values equal to `v`.
#
# Examples:
# ```
#   jForall (JInteger 42) (JInteger 42, JInteger 42, Nil) = True
#   jForall (JInteger 42) (JInteger 42, JString "Alice", Nil) = False
#   jForall v Nil = True
# ```
#export def jForall (v: JValue): (input: List JValue) => Result Boolean Error = _ ==/ v | Pass

